<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
                    var scene = null;
                    var sceneToRender = null;
                    var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
                    // let animationRunning = true; // ëžœë¤ ì´ë™ì„ ì œì–´í•˜ëŠ” ë³€ìˆ˜

                    // function moveSpritesRandomly(sprites, scene) {
                    //     animationRunning = true; // ëžœë¤ ì´ë™ í™œì„±í™”

                    //     sprites.forEach((sprite) => {
                    //         sprite.originalPosition = sprite.position.clone(); // ì›ëž˜ ìœ„ì¹˜ ì €ìž¥
                    //         sprite.randomOffset = new BABYLON.Vector3(
                    //             (Math.random() - 0.5) * 1000,  // Xì¶• ëžœë¤ ì´ë™
                    //             (Math.random() - 0.5) * 1000,  // Yì¶• ëžœë¤ ì´ë™
                    //             (Math.random() - 0.5) * 1000   // Zì¶• ëžœë¤ ì´ë™
                    //         );
                    //     });

                    //     let time = 0;

                    //     scene.onBeforeRenderObservable.add(() => {
                    //         if (!animationRunning) return; // ðŸ”¥ ë©ˆì¶”ê¸° ì¡°ê±´ ì¶”ê°€!

                    //         time += scene.getEngine().getDeltaTime() * 0.001;  // ì‹œê°„ ì—…ë°ì´íŠ¸

                    //         sprites.forEach((sprite) => {
                    //             // ëžœë¤ ì´ë™ (ë¶€ë“œëŸ½ê²Œ ì›€ì§ì´ë„ë¡ sin í•¨ìˆ˜ í™œìš©)
                    //             sprite.position.x = sprite.originalPosition.x + sprite.randomOffset.x * Math.sin(time);
                    //             sprite.position.y = sprite.originalPosition.y + sprite.randomOffset.y * Math.cos(time);
                    //             sprite.position.z = sprite.originalPosition.z + sprite.randomOffset.z * Math.sin(time * 0.5);
                    //         });
                    //     });

                    //     // 5ì´ˆ í›„ ì›ëž˜ ìœ„ì¹˜ë¡œ ë³µê·€
                    //     setTimeout(() => {
                    //         restoreSprites(sprites, scene);
                    //     }, 7000);
                    // }

                    // function restoreSprites(sprites, scene) {
                    //     animationRunning = false; // ðŸ”¥ ëžœë¤ ì´ë™ ì¤‘ì§€!
                        
                    //     sprites.forEach((sprite) => {
                    //         let animation = new BABYLON.Animation(
                    //             "spriteReturn",
                    //             "position",
                    //             60,
                    //             BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                    //             BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                    //         );

                    //         let keyFrames = [];
                    //         keyFrames.push({ frame: 0, value: sprite.position.clone() });
                    //         keyFrames.push({ frame: 60, value: sprite.originalPosition.clone() });

                    //         animation.setKeys(keyFrames);
                    //         sprite.animations = [animation];
                    //         scene.beginAnimation(sprite, 0, 60, false);
                    //     });

                    //     console.log("ðŸŽ¯ í•œìž ìŠ¤í”„ë¼ì´íŠ¸ ì›ëž˜ ìœ„ì¹˜ë¡œ ë³µê·€ ì¤‘...");

                    //     // ðŸ”¥ 3ì´ˆ ë™ì•ˆ ë©ˆì¶˜ í›„ ë‹¤ì‹œ ëžœë¤ ì´ë™ ì‹œìž‘!
                    //     setTimeout(() => {
                    //         console.log("ðŸ”„ ë‹¤ì‹œ ëžœë¤ ì´ë™ ì‹œìž‘!");
                    //         moveSpritesRandomly(sprites, scene);
                    //     }, 10000);  // ðŸ›‘ 3ì´ˆ ë™ì•ˆ ë©ˆì¶”ê¸° (ì›ëž˜ ìœ„ì¹˜ì—ì„œ ëŒ€ê¸°)
                    // }

                    // function createHanziSprite(scene, x, y, z) {
                    //     let spriteManager = new BABYLON.SpriteManager("hanziManager", "https://i.imgur.com/3x0HfL7.png", 1, { width: 3000, height: 3000 }, scene);
                    //     let hanziSprite = new BABYLON.Sprite("hanzi", spriteManager);
                    //     hanziSprite.position = new BABYLON.Vector3(x,y,z);
                    //     return hanziSprite;

                    // }

                    // var delayCreateScene = function () {
                    //     var scene = new BABYLON.Scene(engine);
                    //     let sprites = [];
                    //     scene.clearColor = new BABYLON.Color4(1, 1, 1, 1); // ë°°ê²½ í°ìƒ‰ ì„¤ì •

                    //     // // ðŸŽ¥ ðŸ”¥ ArcRotateCamera ì¶”ê°€ (ì‚¬ìš©ìžê°€ ë§ˆìš°ìŠ¤ë¡œ íšŒì „ ê°€ëŠ¥)
                    //     // var camera = new BABYLON.ArcRotateCamera("arcCamera", Math.PI / 2, Math.PI / 3, 1500, new BABYLON.Vector3(0, 0, 0), scene);
                    //     // camera.attachControl(canvas, true); // ë§ˆìš°ìŠ¤ ì¡°ìž‘ í™œì„±í™”

                    //     // // ðŸŽ¥ FreeCameraë¥¼ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤ë©´ ì•„ëž˜ ì½”ë“œë¡œ ë³€ê²½!
                    //     var camera = new BABYLON.FreeCamera("freeCamera", new BABYLON.Vector3(0, 200, -600), scene);
                    //     camera.setTarget(BABYLON.Vector3.Zero());
                    //     camera.attachControl(canvas, true);

                    //     BABYLON.SceneLoader.ImportMesh("","ply/","Untitled.glb", scene, function (meshes) {          
                    //         meshes[0].setEnabled(false);
                    //         var pcs = new BABYLON.PointsCloudSystem("pcs", 1, scene);
                    //         // pcs.addSurfacePoints(meshes[1], 500, BABYLON.PointColor.None, 0);
                    //         meshes.slice(1, 30).forEach(mesh => {
                    //             // meshe.scaling = new BABYLON.Vector3(20, 20, 20); // ìŠ¤ì¼€ì¼ ì¡°ì • (100 â†’ 10)
                    //             pcs.addSurfacePoints(mesh, 100, BABYLON.PointColor.None, 0);
                    //         });


                    //         pcs.buildMeshAsync().then(() => {
                    //             pcs.particles.forEach((particle) => {
                    //                 const hanziSprite = createHanziSprite(scene, particle.position.x, particle.position.y, particle.position.z);
                    //                 hanziSprite.width = 40;
                    //                 hanziSprite.height = 40;
                    //                 sprites.push(hanziSprite);
                    //             });

                    //             pcs.mesh.isVisible = false; // í¬ì¸íŠ¸ í´ë¼ìš°ë“œ ìˆ¨ê¸°ê¸°
                    //             moveSpritesRandomly(sprites, scene); // í•œìž ìŠ¤í”„ë¼ì´íŠ¸ ëžœë¤ ì´ë™ ì‹œìž‘!
                    //         });
                    //     });

                    //     return scene;
                    // };

                    // -------------------------------------------------------------------------------------------------

                    let animationRunning = true;
                    let animationObserver = null; // ì¤‘ë³µ ì• ë‹ˆë©”ì´ì…˜ ë°©ì§€ìš© ì˜µì €ë²„
                    let spriteManager = null;     // ì „ì—­ ìŠ¤í”„ë¼ì´íŠ¸ ë§¤ë‹ˆì €
                    let state = "moving"; // "moving", "returning", "paused"
                    let stateStartTime = performance.now();
                    const hanziImages = [
                        "text/kuk.png"
                    ];
                    function moveSpritesSmoothly(sprites, scene) {
                        let targetPositions = [];
                        let speed = 0.05; // ì›€ì§ìž„ ì†ë„ (0.05~0.1 ì‚¬ì´ ì¶”ì²œ)

                        // ì´ˆê¸° ëžœë¤ íƒ€ê²Ÿ ì§€ì •
                        sprites.forEach((sprite) => {
                            sprite.originalPosition = sprite.position.clone();
                            sprite.targetPosition = getNewRandomPosition(sprite.originalPosition);
                            targetPositions.push(sprite.targetPosition.clone());
                        });

                        scene.onBeforeRenderObservable.add(() => {
                            if (!animationRunning) return;

                            const now = performance.now();

                            // ìƒíƒœ ì „í™˜ ë¡œì§
                            if (state === "moving" && now - stateStartTime > 7000) {
                                state = "returning";
                                stateStartTime = now;
                                sprites.forEach((sprite) => {
                                    sprite.targetPosition = sprite.originalPosition.clone();
                                });
                            }

                            if (state === "returning") {
                                let allNearOrigin = sprites.every(sprite =>
                                    BABYLON.Vector3.Distance(sprite.position, sprite.originalPosition) < 1
                                );

                                if (allNearOrigin) {
                                    state = "paused";
                                    stateStartTime = now;
                                }
                            }

                            if (state === "paused" && now - stateStartTime > 20000) {
                                state = "moving";
                                stateStartTime = now;
                                sprites.forEach((sprite) => {
                                    sprite.targetPosition = getNewRandomPosition(sprite.originalPosition);
                                });
                            }

                            // ìœ„ì¹˜ ë³´ê°„ ì ìš©
                            sprites.forEach((sprite) => {
                                sprite.position = BABYLON.Vector3.Lerp(sprite.position, sprite.targetPosition, speed);
                            });
                        });
                    }

                    // ëžœë¤ ìœ„ì¹˜ ìƒì„± í•¨ìˆ˜
                    function getNewRandomPosition(origin) {
                        return origin.add(new BABYLON.Vector3(
                            (Math.random() - 0.5) * 10000,
                            (Math.random() - 0.5) * 10000,
                            (Math.random() - 0.5) * 10000
                        ));
                    }

                    function restoreSprites(sprites, scene) {
                        animationRunning = false;

                        let finishedCount = 0;

                        sprites.forEach(sprite => {
                            const animation = new BABYLON.Animation(
                                "spriteReturn",
                                "position",
                                60,
                                BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                            );

                            animation.setKeys([
                                { frame: 0, value: sprite.position.clone() },
                                { frame: 60, value: sprite.originalPosition.clone() }
                            ]);

                            sprite.animations = [animation];

                            const anim = scene.beginAnimation(sprite, 0, 60, false, 1.0, () => {
                                finishedCount++;
                                if (finishedCount === sprites.length) {
                                    // ëª¨ë“  ìŠ¤í”„ë¼ì´íŠ¸ ë³µê·€ í›„ 0.5ì´ˆ ëŒ€ê¸° â†’ ìžì—°ìŠ¤ëŸ½ê²Œ ìž¬ì‹œìž‘
                                    setTimeout(() => {
                                        moveSpritesRandomly(sprites, scene);
                                    }, 500);
                                }
                            });
                        });

                        console.log("ðŸŽ¯ ìŠ¤í”„ë¼ì´íŠ¸ ì›ìœ„ì¹˜ ë³µê·€ (ìžì—°ìŠ¤ëŸ½ê²Œ ì´ë™ ìž¬ì‹œìž‘ ì˜ˆì •)");
                    }


                    function createHanziSprite(scene, position) {
                        const sprite = new BABYLON.Sprite("hanzi", spriteManager);
                        sprite.position = position.clone();
                        sprite.width = 8;
                        sprite.height = 8;
                        return sprite;
                    }

                    const delayCreateScene = function () {
                        const scene = new BABYLON.Scene(engine);
                        let sprites = [];
                        scene.clearColor = new BABYLON.Color4(1, 1, 1, 1);

                        const camera = new BABYLON.FreeCamera("freeCamera", new BABYLON.Vector3(0, 200, -600), scene);
                        camera.setTarget(BABYLON.Vector3.Zero());
                        camera.attachControl(canvas, true);

                        // ìŠ¤í”„ë¼ì´íŠ¸ ë§¤ë‹ˆì €ëŠ” í•œ ë²ˆë§Œ ìƒì„±
                        spriteManager = new BABYLON.SpriteManager(
                            "hanziManager",
                            hanziImages[0],
                            900000, // ì˜ˆìƒ ìƒì„± ìˆ˜ëŸ‰ (ì—¬ìœ  ìžˆê²Œ ì„¤ì •)
                            { width: 512, height: 512 },
                            scene
                        );

                        BABYLON.SceneLoader.ImportMesh("", "ply/", "Untitled.glb", scene, function (meshes) {
                            meshes[0].setEnabled(false);
                            const pcs = new BABYLON.PointsCloudSystem("pcs", 1, scene);

                            meshes.slice(1, 30).forEach(mesh => {
                                pcs.addSurfacePoints(mesh, 30000, BABYLON.PointColor.None, 0);
                            });

                            pcs.buildMeshAsync().then(() => {
                                pcs.particles.forEach(p => {
                                    const sprite = createHanziSprite(scene, p.position);
                                    sprites.push(sprite);
                                });

                                pcs.mesh.isVisible = false;
                                moveSpritesSmoothly(sprites, scene);
                            });
                        });

                        return scene;
                    };
                    // let animationRunning = true;
                    // let animationObserver = null; // ì¤‘ë³µ ì• ë‹ˆë©”ì´ì…˜ ë°©ì§€ìš© ì˜µì €ë²„
                    // let spriteManager = null;     // ì „ì—­ ìŠ¤í”„ë¼ì´íŠ¸ ë§¤ë‹ˆì €
                    // let state = "moving"; // "moving", "returning", "paused"
                    // let stateStartTime = performance.now();

                    // // ì—¬ëŸ¬ ê°œì˜ í•œìž ì´ë¯¸ì§€ ëª©ë¡
                    // const hanziImages = [
                    //     "text/kuk.png"
                    // ];

                    // // ëžœë¤í•œ í•œìž ì´ë¯¸ì§€ ì„ íƒ í•¨ìˆ˜
                    // function getRandomHanziImage() {
                    //     return hanziImages[Math.floor(Math.random() * hanziImages.length)];
                    // }

                    // function moveSpritesSmoothly(sprites, scene) {
                    //     let targetPositions = [];
                    //     let speed = 0.05; // ì›€ì§ìž„ ì†ë„ (0.05~0.1 ì‚¬ì´ ì¶”ì²œ)

                    //     // ì´ˆê¸° ëžœë¤ íƒ€ê²Ÿ ì§€ì •
                    //     sprites.forEach((sprite) => {
                    //         sprite.originalPosition = sprite.position.clone();
                    //         sprite.targetPosition = getNewRandomPosition(sprite.originalPosition);
                    //         targetPositions.push(sprite.targetPosition.clone());
                    //     });

                    //     scene.onBeforeRenderObservable.add(() => {
                    //         if (!animationRunning) return;

                    //         const now = performance.now();

                    //         // ìƒíƒœ ì „í™˜ ë¡œì§
                    //         if (state === "moving" && now - stateStartTime > 7000) {
                    //             state = "returning";
                    //             stateStartTime = now;
                    //             sprites.forEach((sprite) => {
                    //                 sprite.targetPosition = sprite.originalPosition.clone();
                    //             });
                    //         }

                    //         if (state === "returning") {
                    //             let allNearOrigin = sprites.every(sprite =>
                    //                 BABYLON.Vector3.Distance(sprite.position, sprite.originalPosition) < 1
                    //             );

                    //             if (allNearOrigin) {
                    //                 state = "paused";
                    //                 stateStartTime = now;
                    //             }
                    //         }

                    //         if (state === "paused" && now - stateStartTime > 5000) {
                    //             state = "moving";
                    //             stateStartTime = now;
                    //             sprites.forEach((sprite) => {
                    //                 sprite.targetPosition = getNewRandomPosition(sprite.originalPosition);
                    //             });
                    //         }

                    //         // ìœ„ì¹˜ ë³´ê°„ ì ìš©
                    //         sprites.forEach((sprite) => {
                    //             sprite.position = BABYLON.Vector3.Lerp(sprite.position, sprite.targetPosition, speed);
                    //         });
                    //     });
                    // }

                    // // ëžœë¤ ìœ„ì¹˜ ìƒì„± í•¨ìˆ˜
                    // function getNewRandomPosition(origin) {
                    //     return origin.add(new BABYLON.Vector3(
                    //         (Math.random() - 0.5) * 10000,
                    //         (Math.random() - 0.5) * 10000,
                    //         (Math.random() - 0.5) * 10000
                    //     ));
                    // }

                    // function createHanziSprite(scene, position) {
                    //     const sprite = new BABYLON.Sprite("hanzi", spriteManager);
                    //     sprite.position = position.clone();
                    //     sprite.width = 20;
                    //     sprite.height = 20;

                    //     // ëžœë¤í•œ í•œìž ì´ë¯¸ì§€ ì ìš©
                    //     spriteManager.texture = new BABYLON.Texture(getRandomHanziImage(), scene);

                    //     return sprite;
                    // }

                    // const delayCreateScene = function () {
                    //     const scene = new BABYLON.Scene(engine);
                    //     let sprites = [];
                    //     scene.clearColor = new BABYLON.Color4(1, 1, 1, 1);

                    //     const camera = new BABYLON.FreeCamera("freeCamera", new BABYLON.Vector3(0, 200, -600), scene);
                    //     camera.setTarget(BABYLON.Vector3.Zero());
                    //     camera.attachControl(canvas, true);

                    //     // ìŠ¤í”„ë¼ì´íŠ¸ ë§¤ë‹ˆì € ìƒì„± (í•œìž ì´ë¯¸ì§€ ì¤‘ ì²« ë²ˆì§¸ ì´ë¯¸ì§€ë¥¼ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©)
                    //     spriteManager = new BABYLON.SpriteManager(
                    //         "hanziManager",
                    //         hanziImages[0], // ì²« ë²ˆì§¸ ì´ë¯¸ì§€ë¡œ ì´ˆê¸°í™” (ê°œë³„ ìŠ¤í”„ë¼ì´íŠ¸ì—ì„œ ë³€ê²½ë¨)
                    //         500000, // ì˜ˆìƒ ìƒì„± ìˆ˜ëŸ‰ (ì—¬ìœ  ìžˆê²Œ ì„¤ì •)
                    //         { width: 512, height: 512 },
                    //         scene
                    //     );

                    //     BABYLON.SceneLoader.ImportMesh("", "ply/", "Untitled.glb", scene, function (meshes) {
                    //         meshes[0].setEnabled(false);
                    //         const pcs = new BABYLON.PointsCloudSystem("pcs", 1, scene);

                    //         meshes.slice(1, 30).forEach(mesh => {
                    //             pcs.addSurfacePoints(mesh, 15000, BABYLON.PointColor.None, 0);
                    //         });

                    //         pcs.buildMeshAsync().then(() => {
                    //             pcs.particles.forEach(p => {
                    //                 const sprite = createHanziSprite(scene, p.position);
                    //                 sprites.push(sprite);
                    //             });

                    //             pcs.mesh.isVisible = false;
                    //             moveSpritesSmoothly(sprites, scene);
                    //         });
                    //     });

                    //     return scene;
                    // };

                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = delayCreateScene();};
        initFunction().then(() => {sceneToRender = scene
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
