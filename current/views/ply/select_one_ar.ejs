<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Babylon Template</title>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

</head>

<body>

    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

        var createScene = async function () {

            // This creates a basic Babylon Scene object (non-mesh)
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            // This creates and positions a free camera (non-mesh)
            var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 0, 0), scene);

            // This targets the camera to scene origin
            camera.setTarget(BABYLON.Vector3.Zero());

            camera.speed = 1;
            camera.inertia = 1;

            // This attaches the camera to the canvas
            camera.attachControl(canvas, true);

            // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
            var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

            // Default intensity is 1. Let's dim the light a small amount
            light.intensity = 0.7;

            // GUI
            var planeActive = true;
            var plane = BABYLON.Mesh.CreatePlane("plane", 2, scene);
            plane.isNearPickable = true;
            plane.position = new BABYLON.Vector3(0, 1.2, 0.8);

            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(plane);

            // Main panel
            var mainPanel = new BABYLON.GUI.ScrollViewer();
            mainPanel.width = "800px";
            mainPanel.height = "600px";
            mainPanel.background = "#F7F7F7";
            mainPanel.cornerRadius = "10";
            advancedTexture.addControl(mainPanel);

            // Button panel
            var buttonPanel = new BABYLON.GUI.StackPanel();
            buttonPanel.width = "400px";
            buttonPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            mainPanel.addControl(buttonPanel);

            var header = new BABYLON.GUI.TextBlock();
            header.text = "불러올 파일 선택";
            header.height = "100px";
            header.color = fontColor;
            header.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            header.fontSize = "40";
            header.fontFamily = "times new roman";
            buttonPanel.addControl(header);

            //ply 리스트
            // var plyFiles = [
            //     "../../plyAssets/list/point_cloud.ply",
            //     "../../plyAssets/list/point_cloud2.ply",
            //     "../../plyAssets/list/Scaniverse_test.ply",
            //     "../../plyAssets/list/banana.ply",
            //     "../../plyAssets/list/pooh.ply",
            //     "../../plyAssets/list/pooh2.ply"
            // ];

            var list = '<%= result%>';
            var plyFiles

            if (list.length == 0) {
                plyFiles = [];
            }

            else {
                plyFiles = list.split(',');
            }

            var selectedGS = [];
            var maxFiles = 1;
            var buttons = [];

            var originColor = "#F2E7D5";
            var clickedColor = "#6D9886";
            var fontColor = "#393E46";

            plyFiles.forEach((file, index) => {
                var button = BABYLON.GUI.Button.CreateSimpleButton("btn" + index, file);
                button.width = "200px";
                button.height = "50px";
                button.cornerRadius = 15;
                button.color = fontColor;
                button.background = originColor;
                button.paddingBottom = "8px";
                button.fontFamily = "times new roman";
                button.onPointerUpObservable.add(async function () {
                    // if (selectedGS) {
                    //     selectedGS.dispose();
                    //     button.background = originColor;
                    // }
                    // selectedGS = new BABYLON.GaussianSplattingMesh("Halo", null, scene);
                    // await selectedGS.loadFileAsync('../../plyAssets/room/' + file);
                    // selectedGS.position = new BABYLON.Vector3(0, 1.5, 1);
                    // selectedGS.scaling = new BABYLON.Vector3(1, 1, 1);
                    // button.background = clickedColor;
                    // // Initialize rotation quaternion if not set
                    // if (!selectedGS.rotationQuaternion) {
                    //     selectedGS.rotationQuaternion = new BABYLON.Quaternion();
                    // }

                    // Check if the file is already loaded
                    let existingIndex = selectedGS.findIndex(gs => gs.index === index);
                    if (existingIndex !== -1) {
                        // Dispose the existing mesh and its gizmo
                        selectedGS[existingIndex].dispose();
                        selectedGS.splice(existingIndex, 1);
                        button.background = originColor;
                        return;
                    }

                    if (selectedGS.length >= maxFiles) {
                        var oldestGS = selectedGS.shift();
                        oldestGS.dispose();
                        // Reset the color of the first button in the list
                        buttons[oldestGS.index].background = originColor;
                    }

                    // Load the new PLY file
                    var gs = new BABYLON.GaussianSplattingMesh("Halo" + index, null, scene);
                    await gs.loadFileAsync('../../plyAssets/room/' + file);
                    gs.position = new BABYLON.Vector3(0, 1.5, 1);
                    gs.scaling = new BABYLON.Vector3(1, 1, 1);
                    gs.index = index;

                    // Add the new PLY file to the list
                    selectedGS.push(gs);

                    // Set the selected button's background to orange
                    button.background = clickedColor;
                });
                buttonPanel.addControl(button);
                buttons.push(button);
            });

            // Slider panel
            var sliderPanel = new BABYLON.GUI.StackPanel();
            sliderPanel.width = "400px";
            sliderPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            mainPanel.addControl(sliderPanel);

            var message = new BABYLON.GUI.TextBlock();
            message.text = "\nX버튼을 눌러 패널 숨기기\n\nA버튼을 눌러 패널 가져오기\n\n컨트롤러로 위치, 시점 조정";
            message.height = "300px";
            message.color = fontColor;
            message.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            message.fontSize = "30";
            message.fontFamily = "times new roman";
            sliderPanel.addControl(message);

            var message2 = new BABYLON.GUI.TextBlock();
            message2.text = "크기 조정";
            message2.height = "100px";
            message2.color = fontColor;
            message2.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            message2.fontSize = "40";
            message2.fontFamily = "times new roman";
            sliderPanel.addControl(message2);

            var addSlider = function (text, min, max, value, callback) {
                var sliderContainer = new BABYLON.GUI.StackPanel();
                sliderContainer.height = "100px";

                var textBlock = new BABYLON.GUI.TextBlock();
                textBlock.text = text + ": " + value.toFixed(2);
                textBlock.height = "30px";
                textBlock.color = fontColor;
                textBlock.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
                sliderContainer.addControl(textBlock);

                var slider = new BABYLON.GUI.Slider();
                slider.minimum = min;
                slider.maximum = max;
                slider.value = value;
                slider.height = "50px";
                slider.width = "400px";
                slider.onValueChangedObservable.add(function (newValue) {
                    textBlock.text = text + ": " + newValue.toFixed(2);
                    callback(newValue);
                });

                sliderContainer.addControl(slider);
                sliderPanel.addControl(sliderContainer);
            };

            addSlider("Scale", 0.1, 10, 1, function (value) {
                if (selectedGS) {
                    selectedGS.scaling = new BABYLON.Vector3(value, value, value);
                }
            });

            var exitButton = BABYLON.GUI.Button.CreateSimpleButton("gizmoButton", "종료");
            exitButton.width = "200px";
            exitButton.height = "50px";
            exitButton.cornerRadius = 20;
            exitButton.color = fontColor;
            exitButton.background = clickedColor;
            exitButton.paddingBottom = "8px";
            exitButton.fontFamily = "times new roman";
            exitButton.onPointerUpObservable.add(() => {
                xrHelper.baseExperience.exitXRAsync();
            });
            sliderPanel.addControl(exitButton);



            // XR
            const xrHelper = await scene.createDefaultXRExperienceAsync({
                uiOptions: {
                    sessionMode: "immersive-ar",
                },
                disableTeleportation: true,
            });

            const featureManager = xrHelper.baseExperience.featuresManager;
            featureManager.enableFeature(BABYLON.WebXRFeatureName.MOVEMENT, 'latest', {
                xrInput: xrHelper.input,
            });

            xrHelper.input.onControllerAddedObservable.add((controller) => {
                controller.onMotionControllerInitObservable.add((motionController) => {
                    if (motionController.handness === 'left') {
                        const xr_ids = motionController.getComponentIds();
                        let triggerComponent = motionController.getComponent(xr_ids[3]); // xr-standard-trigger
                        triggerComponent.onButtonStateChangedObservable.add(() => {
                            if (triggerComponent.pressed) {
                                if(planeActive){
                                    plane.isVisible = false;
                                    planeActive = false;
                                } else {
                                    plane.isVisible = true;
                                    planeActive = true;
                                }
                            }
                        });
                    }
                    if (motionController.handness === 'right') {
                        const xr_ids = motionController.getComponentIds();
                        let triggerComponent = motionController.getComponent(xr_ids[3]); // "X" button
                        triggerComponent.onButtonStateChangedObservable.add(() => {
                            if (triggerComponent.pressed) {
                                if (xrHelper.baseExperience && xrHelper.baseExperience.camera) {
                                    const xrCamera = xrHelper.baseExperience.camera;
                                    plane.position.x = xrCamera.position.x;
                                    plane.position.y = xrCamera.position.y - 0.1;
                                    plane.position.z = xrCamera.position.z + 0.8;
                                }
                            }
                        });
                    }
                });
            });

            return scene;
        };

        // call the createScene function
        createScene().then(scene => {
            engine.runRenderLoop(function () {
                scene.render();
            });
        }).catch(error => {
            console.error("Failed to create scene:", error);
        });

        // const scene = createScene();

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
            engine.resize();
        });


    </script>

</body>

</html>